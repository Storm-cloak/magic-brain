{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.CanvasUtils = void 0;\n\nconst ColorUtils_1 = require(\"./ColorUtils\");\n\nconst NumberUtils_1 = require(\"./NumberUtils\");\n\nclass CanvasUtils {\n  static paintBase(context, dimension, baseColor) {\n    context.save();\n    context.fillStyle = baseColor !== null && baseColor !== void 0 ? baseColor : \"rgba(0,0,0,0)\";\n    context.fillRect(0, 0, dimension.width, dimension.height);\n    context.restore();\n  }\n\n  static clear(context, dimension) {\n    context.clearRect(0, 0, dimension.width, dimension.height);\n  }\n\n  static drawLinkLine(context, width, begin, end, maxDistance, canvasSize, warp, backgroundMask, composite, colorLine, opacity, shadow) {\n    let drawn = false;\n\n    if (NumberUtils_1.NumberUtils.getDistance(begin, end) <= maxDistance) {\n      CanvasUtils.drawLine(context, begin, end);\n      drawn = true;\n    } else if (warp) {\n      let pi1;\n      let pi2;\n      const endNE = {\n        x: end.x - canvasSize.width,\n        y: end.y\n      };\n      const {\n        dx,\n        dy,\n        distance\n      } = NumberUtils_1.NumberUtils.getDistances(begin, endNE);\n\n      if (distance <= maxDistance) {\n        const yi = begin.y - dy / dx * begin.x;\n        pi1 = {\n          x: 0,\n          y: yi\n        };\n        pi2 = {\n          x: canvasSize.width,\n          y: yi\n        };\n      } else {\n        const endSW = {\n          x: end.x,\n          y: end.y - canvasSize.height\n        };\n        const {\n          dx,\n          dy,\n          distance\n        } = NumberUtils_1.NumberUtils.getDistances(begin, endSW);\n\n        if (distance <= maxDistance) {\n          const yi = begin.y - dy / dx * begin.x;\n          const xi = -yi / (dy / dx);\n          pi1 = {\n            x: xi,\n            y: 0\n          };\n          pi2 = {\n            x: xi,\n            y: canvasSize.height\n          };\n        } else {\n          const endSE = {\n            x: end.x - canvasSize.width,\n            y: end.y - canvasSize.height\n          };\n          const {\n            dx,\n            dy,\n            distance\n          } = NumberUtils_1.NumberUtils.getDistances(begin, endSE);\n\n          if (distance <= maxDistance) {\n            const yi = begin.y - dy / dx * begin.x;\n            const xi = -yi / (dy / dx);\n            pi1 = {\n              x: xi,\n              y: yi\n            };\n            pi2 = {\n              x: pi1.x + canvasSize.width,\n              y: pi1.y + canvasSize.height\n            };\n          }\n        }\n      }\n\n      if (pi1 && pi2) {\n        CanvasUtils.drawLine(context, begin, pi1);\n        CanvasUtils.drawLine(context, end, pi2);\n        drawn = true;\n      }\n    }\n\n    if (!drawn) {\n      return;\n    }\n\n    context.lineWidth = width;\n\n    if (backgroundMask) {\n      context.globalCompositeOperation = composite;\n    }\n\n    context.strokeStyle = ColorUtils_1.ColorUtils.getStyleFromRgb(colorLine, opacity);\n\n    if (shadow.enable) {\n      const shadowColor = ColorUtils_1.ColorUtils.colorToRgb(shadow.color);\n\n      if (shadowColor) {\n        context.shadowBlur = shadow.blur;\n        context.shadowColor = ColorUtils_1.ColorUtils.getStyleFromRgb(shadowColor);\n      }\n    }\n\n    context.stroke();\n  }\n\n  static drawLinkTriangle(context, width, pos1, pos2, pos3, backgroundMask, composite, colorTriangle, opacityTriangle) {\n    CanvasUtils.drawTriangle(context, pos1, pos2, pos3);\n    context.lineWidth = width;\n\n    if (backgroundMask) {\n      context.globalCompositeOperation = composite;\n    }\n\n    context.fillStyle = ColorUtils_1.ColorUtils.getStyleFromRgb(colorTriangle, opacityTriangle);\n    context.fill();\n  }\n\n  static drawConnectLine(context, width, lineStyle, begin, end) {\n    context.save();\n    CanvasUtils.drawLine(context, begin, end);\n    context.lineWidth = width;\n    context.strokeStyle = lineStyle;\n    context.stroke();\n    context.restore();\n  }\n\n  static gradient(context, p1, p2, opacity) {\n    const gradStop = Math.floor(p2.getRadius() / p1.getRadius());\n    const color1 = p1.getFillColor();\n    const color2 = p2.getFillColor();\n\n    if (!color1 || !color2) {\n      return;\n    }\n\n    const sourcePos = p1.getPosition();\n    const destPos = p2.getPosition();\n    const midRgb = ColorUtils_1.ColorUtils.mix(color1, color2, p1.getRadius(), p2.getRadius());\n    const grad = context.createLinearGradient(sourcePos.x, sourcePos.y, destPos.x, destPos.y);\n    grad.addColorStop(0, ColorUtils_1.ColorUtils.getStyleFromHsl(color1, opacity));\n    grad.addColorStop(gradStop > 1 ? 1 : gradStop, ColorUtils_1.ColorUtils.getStyleFromRgb(midRgb, opacity));\n    grad.addColorStop(1, ColorUtils_1.ColorUtils.getStyleFromHsl(color2, opacity));\n    return grad;\n  }\n\n  static drawGrabLine(context, width, begin, end, colorLine, opacity) {\n    context.save();\n    CanvasUtils.drawLine(context, begin, end);\n    context.strokeStyle = ColorUtils_1.ColorUtils.getStyleFromRgb(colorLine, opacity);\n    context.lineWidth = width;\n    context.stroke();\n    context.restore();\n  }\n\n  static drawLight(container, context, mousePos) {\n    const lightOptions = container.options.interactivity.modes.light.area;\n    context.beginPath();\n    context.arc(mousePos.x, mousePos.y, lightOptions.radius, 0, 2 * Math.PI);\n    const gradientAmbientLight = context.createRadialGradient(mousePos.x, mousePos.y, 0, mousePos.x, mousePos.y, lightOptions.radius);\n    const gradient = lightOptions.gradient;\n    const gradientRgb = {\n      start: ColorUtils_1.ColorUtils.colorToRgb(gradient.start),\n      stop: ColorUtils_1.ColorUtils.colorToRgb(gradient.stop)\n    };\n\n    if (!gradientRgb.start || !gradientRgb.stop) {\n      return;\n    }\n\n    gradientAmbientLight.addColorStop(0, ColorUtils_1.ColorUtils.getStyleFromRgb(gradientRgb.start));\n    gradientAmbientLight.addColorStop(1, ColorUtils_1.ColorUtils.getStyleFromRgb(gradientRgb.stop));\n    context.fillStyle = gradientAmbientLight;\n    context.fill();\n  }\n\n  static drawParticleShadow(container, context, particle, mousePos) {\n    const pos = particle.getPosition();\n    const shadowOptions = container.options.interactivity.modes.light.shadow;\n    context.save();\n    const radius = particle.getRadius();\n    const sides = particle.sides;\n    const full = Math.PI * 2 / sides;\n    const angle = -particle.rotate.value + Math.PI / 4;\n    const factor = 1;\n    const dots = [];\n\n    for (let i = 0; i < sides; i++) {\n      dots.push({\n        x: pos.x + radius * Math.sin(angle + full * i) * factor,\n        y: pos.y + radius * Math.cos(angle + full * i) * factor\n      });\n    }\n\n    const points = [];\n    const shadowLength = shadowOptions.length;\n\n    for (const dot of dots) {\n      const angle = Math.atan2(mousePos.y - dot.y, mousePos.x - dot.x);\n      const endX = dot.x + shadowLength * Math.sin(-angle - Math.PI / 2);\n      const endY = dot.y + shadowLength * Math.cos(-angle - Math.PI / 2);\n      points.push({\n        endX: endX,\n        endY: endY,\n        startX: dot.x,\n        startY: dot.y\n      });\n    }\n\n    const shadowRgb = ColorUtils_1.ColorUtils.colorToRgb(shadowOptions.color);\n\n    if (!shadowRgb) {\n      return;\n    }\n\n    const shadowColor = ColorUtils_1.ColorUtils.getStyleFromRgb(shadowRgb);\n\n    for (let i = points.length - 1; i >= 0; i--) {\n      const n = i == points.length - 1 ? 0 : i + 1;\n      context.beginPath();\n      context.moveTo(points[i].startX, points[i].startY);\n      context.lineTo(points[n].startX, points[n].startY);\n      context.lineTo(points[n].endX, points[n].endY);\n      context.lineTo(points[i].endX, points[i].endY);\n      context.fillStyle = shadowColor;\n      context.fill();\n    }\n\n    context.restore();\n  }\n\n  static drawParticle(container, context, particle, delta, fillColorValue, strokeColorValue, backgroundMask, composite, radius, opacity, shadow) {\n    const pos = particle.getPosition();\n    context.save();\n    context.translate(pos.x, pos.y);\n    context.beginPath();\n    const angle = particle.rotate.value + (particle.particlesOptions.rotate.path ? particle.pathAngle : 0);\n\n    if (angle !== 0) {\n      context.rotate(angle);\n    }\n\n    if (backgroundMask) {\n      context.globalCompositeOperation = composite;\n    }\n\n    const shadowColor = particle.shadowColor;\n\n    if (shadow.enable && shadowColor) {\n      context.shadowBlur = shadow.blur;\n      context.shadowColor = ColorUtils_1.ColorUtils.getStyleFromRgb(shadowColor);\n      context.shadowOffsetX = shadow.offset.x;\n      context.shadowOffsetY = shadow.offset.y;\n    }\n\n    if (fillColorValue) {\n      context.fillStyle = fillColorValue;\n    }\n\n    const stroke = particle.stroke;\n    context.lineWidth = particle.strokeWidth;\n\n    if (strokeColorValue) {\n      context.strokeStyle = strokeColorValue;\n    }\n\n    CanvasUtils.drawShape(container, context, particle, radius, opacity, delta);\n\n    if (stroke.width > 0) {\n      context.stroke();\n    }\n\n    if (particle.close) {\n      context.closePath();\n    }\n\n    if (particle.fill) {\n      context.fill();\n    }\n\n    context.restore();\n    context.save();\n    context.translate(pos.x, pos.y);\n\n    if (angle !== 0) {\n      context.rotate(angle);\n    }\n\n    if (backgroundMask) {\n      context.globalCompositeOperation = composite;\n    }\n\n    CanvasUtils.drawShapeAfterEffect(container, context, particle, radius, opacity, delta);\n    context.restore();\n  }\n\n  static drawShape(container, context, particle, radius, opacity, delta) {\n    if (!particle.shape) {\n      return;\n    }\n\n    const drawer = container.drawers.get(particle.shape);\n\n    if (!drawer) {\n      return;\n    }\n\n    drawer.draw(context, particle, radius, opacity, delta.value, container.retina.pixelRatio);\n  }\n\n  static drawShapeAfterEffect(container, context, particle, radius, opacity, delta) {\n    if (!particle.shape) {\n      return;\n    }\n\n    const drawer = container.drawers.get(particle.shape);\n\n    if (!(drawer === null || drawer === void 0 ? void 0 : drawer.afterEffect)) {\n      return;\n    }\n\n    drawer.afterEffect(context, particle, radius, opacity, delta.value, container.retina.pixelRatio);\n  }\n\n  static drawPlugin(context, plugin, delta) {\n    if (plugin.draw !== undefined) {\n      context.save();\n      plugin.draw(context, delta);\n      context.restore();\n    }\n  }\n\n  static drawLine(context, begin, end) {\n    context.beginPath();\n    context.moveTo(begin.x, begin.y);\n    context.lineTo(end.x, end.y);\n    context.closePath();\n  }\n\n  static drawTriangle(context, p1, p2, p3) {\n    context.beginPath();\n    context.moveTo(p1.x, p1.y);\n    context.lineTo(p2.x, p2.y);\n    context.lineTo(p3.x, p3.y);\n    context.closePath();\n  }\n\n}\n\nexports.CanvasUtils = CanvasUtils;","map":{"version":3,"sources":["/home/rustam/SCK/WebProgramming/React/smart-brain/face-detection-front/node_modules/tsparticles/dist/Utils/CanvasUtils.js"],"names":["Object","defineProperty","exports","value","CanvasUtils","ColorUtils_1","require","NumberUtils_1","paintBase","context","dimension","baseColor","save","fillStyle","fillRect","width","height","restore","clear","clearRect","drawLinkLine","begin","end","maxDistance","canvasSize","warp","backgroundMask","composite","colorLine","opacity","shadow","drawn","NumberUtils","getDistance","drawLine","pi1","pi2","endNE","x","y","dx","dy","distance","getDistances","yi","endSW","xi","endSE","lineWidth","globalCompositeOperation","strokeStyle","ColorUtils","getStyleFromRgb","enable","shadowColor","colorToRgb","color","shadowBlur","blur","stroke","drawLinkTriangle","pos1","pos2","pos3","colorTriangle","opacityTriangle","drawTriangle","fill","drawConnectLine","lineStyle","gradient","p1","p2","gradStop","Math","floor","getRadius","color1","getFillColor","color2","sourcePos","getPosition","destPos","midRgb","mix","grad","createLinearGradient","addColorStop","getStyleFromHsl","drawGrabLine","drawLight","container","mousePos","lightOptions","options","interactivity","modes","light","area","beginPath","arc","radius","PI","gradientAmbientLight","createRadialGradient","gradientRgb","start","stop","drawParticleShadow","particle","pos","shadowOptions","sides","full","angle","rotate","factor","dots","i","push","sin","cos","points","shadowLength","length","dot","atan2","endX","endY","startX","startY","shadowRgb","n","moveTo","lineTo","drawParticle","delta","fillColorValue","strokeColorValue","translate","particlesOptions","path","pathAngle","shadowOffsetX","offset","shadowOffsetY","strokeWidth","drawShape","close","closePath","drawShapeAfterEffect","shape","drawer","drawers","get","draw","retina","pixelRatio","afterEffect","drawPlugin","plugin","undefined","p3"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.CanvasUtils = void 0;\nconst ColorUtils_1 = require(\"./ColorUtils\");\nconst NumberUtils_1 = require(\"./NumberUtils\");\nclass CanvasUtils {\n    static paintBase(context, dimension, baseColor) {\n        context.save();\n        context.fillStyle = baseColor !== null && baseColor !== void 0 ? baseColor : \"rgba(0,0,0,0)\";\n        context.fillRect(0, 0, dimension.width, dimension.height);\n        context.restore();\n    }\n    static clear(context, dimension) {\n        context.clearRect(0, 0, dimension.width, dimension.height);\n    }\n    static drawLinkLine(context, width, begin, end, maxDistance, canvasSize, warp, backgroundMask, composite, colorLine, opacity, shadow) {\n        let drawn = false;\n        if (NumberUtils_1.NumberUtils.getDistance(begin, end) <= maxDistance) {\n            CanvasUtils.drawLine(context, begin, end);\n            drawn = true;\n        }\n        else if (warp) {\n            let pi1;\n            let pi2;\n            const endNE = {\n                x: end.x - canvasSize.width,\n                y: end.y,\n            };\n            const { dx, dy, distance } = NumberUtils_1.NumberUtils.getDistances(begin, endNE);\n            if (distance <= maxDistance) {\n                const yi = begin.y - (dy / dx) * begin.x;\n                pi1 = { x: 0, y: yi };\n                pi2 = { x: canvasSize.width, y: yi };\n            }\n            else {\n                const endSW = {\n                    x: end.x,\n                    y: end.y - canvasSize.height,\n                };\n                const { dx, dy, distance } = NumberUtils_1.NumberUtils.getDistances(begin, endSW);\n                if (distance <= maxDistance) {\n                    const yi = begin.y - (dy / dx) * begin.x;\n                    const xi = -yi / (dy / dx);\n                    pi1 = { x: xi, y: 0 };\n                    pi2 = { x: xi, y: canvasSize.height };\n                }\n                else {\n                    const endSE = {\n                        x: end.x - canvasSize.width,\n                        y: end.y - canvasSize.height,\n                    };\n                    const { dx, dy, distance } = NumberUtils_1.NumberUtils.getDistances(begin, endSE);\n                    if (distance <= maxDistance) {\n                        const yi = begin.y - (dy / dx) * begin.x;\n                        const xi = -yi / (dy / dx);\n                        pi1 = { x: xi, y: yi };\n                        pi2 = { x: pi1.x + canvasSize.width, y: pi1.y + canvasSize.height };\n                    }\n                }\n            }\n            if (pi1 && pi2) {\n                CanvasUtils.drawLine(context, begin, pi1);\n                CanvasUtils.drawLine(context, end, pi2);\n                drawn = true;\n            }\n        }\n        if (!drawn) {\n            return;\n        }\n        context.lineWidth = width;\n        if (backgroundMask) {\n            context.globalCompositeOperation = composite;\n        }\n        context.strokeStyle = ColorUtils_1.ColorUtils.getStyleFromRgb(colorLine, opacity);\n        if (shadow.enable) {\n            const shadowColor = ColorUtils_1.ColorUtils.colorToRgb(shadow.color);\n            if (shadowColor) {\n                context.shadowBlur = shadow.blur;\n                context.shadowColor = ColorUtils_1.ColorUtils.getStyleFromRgb(shadowColor);\n            }\n        }\n        context.stroke();\n    }\n    static drawLinkTriangle(context, width, pos1, pos2, pos3, backgroundMask, composite, colorTriangle, opacityTriangle) {\n        CanvasUtils.drawTriangle(context, pos1, pos2, pos3);\n        context.lineWidth = width;\n        if (backgroundMask) {\n            context.globalCompositeOperation = composite;\n        }\n        context.fillStyle = ColorUtils_1.ColorUtils.getStyleFromRgb(colorTriangle, opacityTriangle);\n        context.fill();\n    }\n    static drawConnectLine(context, width, lineStyle, begin, end) {\n        context.save();\n        CanvasUtils.drawLine(context, begin, end);\n        context.lineWidth = width;\n        context.strokeStyle = lineStyle;\n        context.stroke();\n        context.restore();\n    }\n    static gradient(context, p1, p2, opacity) {\n        const gradStop = Math.floor(p2.getRadius() / p1.getRadius());\n        const color1 = p1.getFillColor();\n        const color2 = p2.getFillColor();\n        if (!color1 || !color2) {\n            return;\n        }\n        const sourcePos = p1.getPosition();\n        const destPos = p2.getPosition();\n        const midRgb = ColorUtils_1.ColorUtils.mix(color1, color2, p1.getRadius(), p2.getRadius());\n        const grad = context.createLinearGradient(sourcePos.x, sourcePos.y, destPos.x, destPos.y);\n        grad.addColorStop(0, ColorUtils_1.ColorUtils.getStyleFromHsl(color1, opacity));\n        grad.addColorStop(gradStop > 1 ? 1 : gradStop, ColorUtils_1.ColorUtils.getStyleFromRgb(midRgb, opacity));\n        grad.addColorStop(1, ColorUtils_1.ColorUtils.getStyleFromHsl(color2, opacity));\n        return grad;\n    }\n    static drawGrabLine(context, width, begin, end, colorLine, opacity) {\n        context.save();\n        CanvasUtils.drawLine(context, begin, end);\n        context.strokeStyle = ColorUtils_1.ColorUtils.getStyleFromRgb(colorLine, opacity);\n        context.lineWidth = width;\n        context.stroke();\n        context.restore();\n    }\n    static drawLight(container, context, mousePos) {\n        const lightOptions = container.options.interactivity.modes.light.area;\n        context.beginPath();\n        context.arc(mousePos.x, mousePos.y, lightOptions.radius, 0, 2 * Math.PI);\n        const gradientAmbientLight = context.createRadialGradient(mousePos.x, mousePos.y, 0, mousePos.x, mousePos.y, lightOptions.radius);\n        const gradient = lightOptions.gradient;\n        const gradientRgb = {\n            start: ColorUtils_1.ColorUtils.colorToRgb(gradient.start),\n            stop: ColorUtils_1.ColorUtils.colorToRgb(gradient.stop),\n        };\n        if (!gradientRgb.start || !gradientRgb.stop) {\n            return;\n        }\n        gradientAmbientLight.addColorStop(0, ColorUtils_1.ColorUtils.getStyleFromRgb(gradientRgb.start));\n        gradientAmbientLight.addColorStop(1, ColorUtils_1.ColorUtils.getStyleFromRgb(gradientRgb.stop));\n        context.fillStyle = gradientAmbientLight;\n        context.fill();\n    }\n    static drawParticleShadow(container, context, particle, mousePos) {\n        const pos = particle.getPosition();\n        const shadowOptions = container.options.interactivity.modes.light.shadow;\n        context.save();\n        const radius = particle.getRadius();\n        const sides = particle.sides;\n        const full = (Math.PI * 2) / sides;\n        const angle = -particle.rotate.value + Math.PI / 4;\n        const factor = 1;\n        const dots = [];\n        for (let i = 0; i < sides; i++) {\n            dots.push({\n                x: pos.x + radius * Math.sin(angle + full * i) * factor,\n                y: pos.y + radius * Math.cos(angle + full * i) * factor,\n            });\n        }\n        const points = [];\n        const shadowLength = shadowOptions.length;\n        for (const dot of dots) {\n            const angle = Math.atan2(mousePos.y - dot.y, mousePos.x - dot.x);\n            const endX = dot.x + shadowLength * Math.sin(-angle - Math.PI / 2);\n            const endY = dot.y + shadowLength * Math.cos(-angle - Math.PI / 2);\n            points.push({\n                endX: endX,\n                endY: endY,\n                startX: dot.x,\n                startY: dot.y,\n            });\n        }\n        const shadowRgb = ColorUtils_1.ColorUtils.colorToRgb(shadowOptions.color);\n        if (!shadowRgb) {\n            return;\n        }\n        const shadowColor = ColorUtils_1.ColorUtils.getStyleFromRgb(shadowRgb);\n        for (let i = points.length - 1; i >= 0; i--) {\n            const n = i == points.length - 1 ? 0 : i + 1;\n            context.beginPath();\n            context.moveTo(points[i].startX, points[i].startY);\n            context.lineTo(points[n].startX, points[n].startY);\n            context.lineTo(points[n].endX, points[n].endY);\n            context.lineTo(points[i].endX, points[i].endY);\n            context.fillStyle = shadowColor;\n            context.fill();\n        }\n        context.restore();\n    }\n    static drawParticle(container, context, particle, delta, fillColorValue, strokeColorValue, backgroundMask, composite, radius, opacity, shadow) {\n        const pos = particle.getPosition();\n        context.save();\n        context.translate(pos.x, pos.y);\n        context.beginPath();\n        const angle = particle.rotate.value + (particle.particlesOptions.rotate.path ? particle.pathAngle : 0);\n        if (angle !== 0) {\n            context.rotate(angle);\n        }\n        if (backgroundMask) {\n            context.globalCompositeOperation = composite;\n        }\n        const shadowColor = particle.shadowColor;\n        if (shadow.enable && shadowColor) {\n            context.shadowBlur = shadow.blur;\n            context.shadowColor = ColorUtils_1.ColorUtils.getStyleFromRgb(shadowColor);\n            context.shadowOffsetX = shadow.offset.x;\n            context.shadowOffsetY = shadow.offset.y;\n        }\n        if (fillColorValue) {\n            context.fillStyle = fillColorValue;\n        }\n        const stroke = particle.stroke;\n        context.lineWidth = particle.strokeWidth;\n        if (strokeColorValue) {\n            context.strokeStyle = strokeColorValue;\n        }\n        CanvasUtils.drawShape(container, context, particle, radius, opacity, delta);\n        if (stroke.width > 0) {\n            context.stroke();\n        }\n        if (particle.close) {\n            context.closePath();\n        }\n        if (particle.fill) {\n            context.fill();\n        }\n        context.restore();\n        context.save();\n        context.translate(pos.x, pos.y);\n        if (angle !== 0) {\n            context.rotate(angle);\n        }\n        if (backgroundMask) {\n            context.globalCompositeOperation = composite;\n        }\n        CanvasUtils.drawShapeAfterEffect(container, context, particle, radius, opacity, delta);\n        context.restore();\n    }\n    static drawShape(container, context, particle, radius, opacity, delta) {\n        if (!particle.shape) {\n            return;\n        }\n        const drawer = container.drawers.get(particle.shape);\n        if (!drawer) {\n            return;\n        }\n        drawer.draw(context, particle, radius, opacity, delta.value, container.retina.pixelRatio);\n    }\n    static drawShapeAfterEffect(container, context, particle, radius, opacity, delta) {\n        if (!particle.shape) {\n            return;\n        }\n        const drawer = container.drawers.get(particle.shape);\n        if (!(drawer === null || drawer === void 0 ? void 0 : drawer.afterEffect)) {\n            return;\n        }\n        drawer.afterEffect(context, particle, radius, opacity, delta.value, container.retina.pixelRatio);\n    }\n    static drawPlugin(context, plugin, delta) {\n        if (plugin.draw !== undefined) {\n            context.save();\n            plugin.draw(context, delta);\n            context.restore();\n        }\n    }\n    static drawLine(context, begin, end) {\n        context.beginPath();\n        context.moveTo(begin.x, begin.y);\n        context.lineTo(end.x, end.y);\n        context.closePath();\n    }\n    static drawTriangle(context, p1, p2, p3) {\n        context.beginPath();\n        context.moveTo(p1.x, p1.y);\n        context.lineTo(p2.x, p2.y);\n        context.lineTo(p3.x, p3.y);\n        context.closePath();\n    }\n}\nexports.CanvasUtils = CanvasUtils;\n"]},"metadata":{},"sourceType":"script"}